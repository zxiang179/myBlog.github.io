<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JVM参数配置]]></title>
      <url>%2F2017%2F05%2F03%2FJVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[虚拟机参数在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排除会有一定的帮助，为此，虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行java虚拟机，就可以在系统运行是打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实主要就是围绕着堆栈方法区配置。 堆分配参数-XX:+PrintGC :使用这个参数，虚拟机启动后只要遇到GC就会打印日志。-XX:+UseSerialGC :配置串行回收器。-XX:+PrintGCDetails: 可以查看详细信息，包括各个区的情况。-Xms:设置java程序启动时的初始堆大小。-Xmx:设置java程序能获得最大堆的大小-Xmx20m -Xms5m -XX:+PrintCommandLineFlags:可以将隐式或显示传给虚拟机的参数输出。总结：在实际工作中，我们可以直接将初始堆的大小和最大堆大小设置相等，这样的好处是可以减少运行时的垃圾回收次数，从而提高性能。 123456789101112131415161718192021222324252627282930313233public class Test01 &#123; public static void main(String[] args) &#123; //-XX:+PrintGC -Xms5m -Xmx20m -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintCommandLineFlags //1: //-XX:+PrintGC -Xms5m -Xmx20m -XX:+UseSerialGC -XX:+PrintGCDetails //查看GC信息 System.out.println(&quot;max memory:&quot;+Runtime.getRuntime().maxMemory()); System.out.println(&quot;free memory:&quot;+Runtime.getRuntime().freeMemory()); System.out.println(&quot;total memory:&quot;+Runtime.getRuntime().totalMemory()); byte[] b1 = new byte[1*1024*1024]; System.out.println(&quot;分配了1M&quot;); System.out.println(&quot;max memory:&quot;+Runtime.getRuntime().maxMemory()); System.out.println(&quot;free memory:&quot;+Runtime.getRuntime().freeMemory()); System.out.println(&quot;total memory:&quot;+Runtime.getRuntime().totalMemory()); byte[] b2 = new byte[4*1024*1024]; System.out.println(&quot;分配了4M&quot;); System.out.println(&quot;max memory:&quot;+Runtime.getRuntime().maxMemory()); System.out.println(&quot;free memory:&quot;+Runtime.getRuntime().freeMemory()); System.out.println(&quot;total memory:&quot;+Runtime.getRuntime().totalMemory()); int a = 0x00000000fee10000; int b = 0x00000000fec00000; System.out.println(&quot;结果为1920k，但实际结果：&quot;+(a-b)/1024); &#125;&#125; 堆分配参数（二）-Xmn:可以设置新生代的大小，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，新生代大小一般会设置整个堆空间的1/3到1/4左右。-XX:SurvivorRatio:用来设置新生代中eden空间和from/to空间的比例。含义：-XX:SurvivorRatio=eden/from=eden/to总结：不同的堆分布情况，对系统的执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能的将对象预留在新生代，减少老年代的GC次数。除了可以设置新生代的绝对大小(-Xmn),还可以使用(-XX:NewRation)设置新生代和老年代的比例：-XX:newRatio=老年代/新生代 123456789101112131415161718192021public class Test02 &#123; public static void main(String[] args) &#123; //第一次配置 eden 2 =from 1+ to 1 //-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC //第二次配置 //-Xms20m -Xmx20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC //第三次配置 //-XX:NewRatio=老年代/新生代 //-Xms20m -Xmx20m -XX:NewRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC byte[] b=null; //连续向系统申请10m空间 for(int i=0;i&lt;10;i++)&#123; b=new byte[1*1024*1024]; &#125; &#125; &#125; 堆溢出处理在java程序运行的过程中，如果堆空间不足，则会抛出内存溢出的错误(Out Of Memory),一旦这类问题发生在生产环境，可能引起严重的业务中断，java虚拟机提供了-XX:+HeapDumpOnOutOfMemoryError,使用该参数可以在内存溢出时导出整个堆信息，与之配合的还有参数，-XX:HeapDumpPath,可以设置导出堆的路径。内存分析工具：Memory Analyzer 1.5.0 123456789101112public class Test3 &#123; public static void main(String[] args) &#123; //-Xms2m -Xmx2m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=e:/Test03.dump //堆内存溢出 Vector vector = new Vector(); for(int i=0;i&lt;5;i++)&#123; vector.add(new Byte[1*1024*1024]); &#125; &#125;&#125; 栈配置Java虚拟机提供了参数-Xss来指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大深度。 12345678910111213141516171819202122public class Test4 &#123; //-Xss1m //-Xss5m //栈调用深度 private static int count; public static void recursion()&#123; count++; recursion(); &#125; public static void main(String[] args) &#123; try &#123; recursion(); &#125; catch (Throwable e) &#123; System.out.println(&quot;调用最大深处：&quot;+count); e.printStackTrace(); &#125; &#125;&#125; 方法区和java堆一样，方法区是一块所有线程共享的内存区域，它用于保存系统的类信息，方法区(永久区)可以保存多少信息可以对其进行配置，在默认情况下，-XX:MaxPermSize为64MB，如果系统运行时产生大量的类，就需要设置一个相对合适的方法区，以免出现永久区内存溢出的问题。-XX:PermSize=64M -XX:MaxPermSize=64M 直接内存配置直接内存也是java程序中非常重要的组成部分，特别是广泛用在NIO中，直接内存跳过了java堆，使java程序可以直接访问原生堆空间，因此在一定的程度上加快了内存空间的访问速度。但是说直接内存一定就可以提高内存访问速度也不见得，具体问题具体分析。相关配置参数：-XX:MaxDirectMemorySize,如果不设置默认值为最大空间，即-Xmx。直接内存使用达到上限时，就会触发垃圾回收，如果不能有效的释放空间，也会引起系统的OOM。 Client和Server虚拟机的工作模式java虚拟机支持Client和Server模式，使用-client可以指定使用Client模式，使用-server可以使用Server模式。（jdk1.7及以后不需要考虑）区别：client模式比server模式启动要快，但长期运行server模式性能远远好于Client模式。 JVM博客：http://www.cnblogs.com/redcreen/tag/jvm/ 源码：https://github.com/zxiang179/JVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[垃圾回收/TomcatGC参数配置]]></title>
      <url>%2F2017%2F05%2F03%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8CTomcatGC%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[垃圾回收垃圾回收有很多种算法，如引用计数法，标记压缩法、复制算法、分带、分区的思想。 引用计数法这是一个比较古老而经典的垃圾回收算法，其核心是在对象被其他所引用时计数器加1，而当引用失效时则减一，但这种方法有非常严重的问题，无法处理循环引用的问题，还有就是每次进行加减操作比较浪费系统性能。 标记清除法就是分别标记和清除两个阶段进行处理内存中的对象，当然这种方式也有很大的弊端，就是空间碎片问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。 复制算法（新生代）其核心思想将内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的残留对象复制到未被使用的内存块中，之后去清除之前正在使用的内存块中所有的对象，反复去交换两个内存的角色，完成垃圾回收。（java中新生代的from和to空间就是使用了这个算法） 标记压缩法（老年代）标记压缩法在标记清除法基础上做了优化，把存活的对象压缩到内存的一端，而后进行垃圾清理。 为什么新生代和老年代使用不同的算法？新生代对象被回收的几率要大于老年代中对象被回收的概率，老年代中的对象都较为稳定。采用不同的算法是为了性能优化考虑。 分代算法根据对象的特点即将内存分为N块，而后根据内存的特点使用不同的算法。对于新生代和老生代来说，新生代回收频率较高，但是每次回收耗时都很短，而老年代回收频率较低，但是耗时会相对较长，所以应该尽量减少老年代的GC。 分区算法分区算法：其主要就是将整个内存分为N多个独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收多个小空间而不是针对整个空间进行GC，从而提升性能，并减少GC的停顿时间。 垃圾回收时的停顿现象垃圾回收的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以更高效的执行，大部分情况下，会要求系统进如一个停顿的状态。停顿的目的是为了终止所有的应用线程，只有这样的系统才不会有新垃圾的产生。同时停顿保证了系统状态在某一个瞬间的一致性，也有利于更好的标记垃圾对象。因此在垃圾回收时，都会产生应用程序的停顿。 对象如何进入老年代一般而言对象首次创建会被放置在新生代的eden区，如果没有GC介入，则对象不会离开eden区，那么eden区的对象如何进入老年代那呢？一般来说只要对象的年龄达到一定的大小，就会自动离开年轻代进入老年代，对象年龄是由对象经历数次GC决定的，在新生代每次GC后，如果没有被回收则年龄加1.虚拟机提供一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代-XX:MaxTenuringThreshold 1234567891011121314151617181920public class Test5 &#123; public static void main(String[] args) &#123; //初始对象在eden区 //-Xmx64m -Xms64m -XX:+PrintGCDetails /*for(int i=0;i&lt;5;i++)&#123; byte[] b = new byte[1024*1024]; &#125;*/ //测试进入老年代的对象 //-Xmx1024m -Xms1024m -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 -XX:+PrintGCDetails //-XX:+PrintHeapATGC for(int k=0;k&lt;20;k++)&#123; for(int j=0;j&lt;300;j++)&#123; byte[] b=new byte[1024*1024]; &#125; &#125; &#125;&#125; 总结：根据设置MaxTenuringThreshold参数可以指定新生代对象经过多少次回收后进入老年代。另外，大对象(新生代eden区无法装入时，也会直接进入老年代)。JVM有个参数可以设置对象的大小超过指定的大小之后，直接晋升老年代。-XX:PretenureSizeThreshold TLABTLAB全称是Thread Local Allocation Buffer即本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。每一个线程会产生一个TLAB，该线程独享的一个工作区域，java虚拟机使用这种TLAB来避免多线程冲突问题。提高了对象分配的效率。TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配在堆上。-XX:+UseTLAB 使用TLAB-XX:+TLABSize设置TLAB大小-XX:TLABRefillWasterFraction 设置维护进入TLAB空间的单个对象大小，它是一个比例值，默认64，即如果对象大于整个空间的1/64,则在堆创建对象。-XX:+PrintTLAB查看TLAB信息-XX:ResizeTLAB自调整TLABRefillWasteFraction阈值。每个线程单独的一块工作内存(volatile) 123456789101112131415161718public class Test7 &#123; public static void alloc()&#123; byte[] b = new byte[2]; &#125; public static void main(String[] args) &#123; //TLAB分配 //-XX:+UseTLAB -XX:+PrintTLAB -XX:TLABSize=102400 -XX:TLABRefillWasteFraction=100 -XX:-DoEscapeAnalysis long start = System.currentTimeMillis(); for(int i=0;i&lt;10000000;i++)&#123; alloc(); &#125; long end = System.currentTimeMillis(); System.out.println(end-start); &#125;&#125; 对象的创建流程图 垃圾收集器在java虚拟机中，垃圾回收器不仅仅只有一种，什么情况下该使用哪种，对性能又有什么影响，这些都是我们需要了解的。 串行垃圾收集器串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用。根据作用于不同的对空间分为新生代串行回收器和老年代串行回收器。-XX：+UseSerialGC参数可以设置使用新生代串行回收器和老年代串行回收器。 并行垃圾收集器并行的垃圾回收器在串行回收器的基础上做了改进，他可以使用多个线程同时进行垃圾回收，对于计算能力强的计算机而言，可以有效的缩短垃圾回收所需的实际时间。 ParNew回收器是一个工作在新生代的垃圾回收器，他只是简单的将串行回收器多线程化，它的回收策略和算法和串行回收器一样。使用-XX:+UseParNewGC 新生代使用ParNew回收器，老年代则使用串行回收器。ParNew回收器工作时的线程数量可以使用-XX：ParallelGCThreads参数指定，一般最好和计算机的CPU相当，避免过多的线程影响性能。 新生代ParallelGC回收器，使用了复制算法的回收器，也是多线程独占形式的回收器，但ParallelGC回收器有一个很重要的特点，就是它非常关注吞吐量。提供了两个参数控制系统的吞吐量-XX: MaxGCPauseMillis:设置最大垃圾收集停顿时间，可用于把虚拟机在GC停顿的时间控制在MaxGCPauseMillis范围内，如果希望减少GC停顿时间可以将MaxGCPauseMillis设置的很小，但是会导致GC频繁，从而增加GC的总时间，降低了吞吐量。所以要根据实际情况设置该值。-XX: GCTimeRatio:设置吞吐量的大小，它是一个0到100之间的整数，默认情况下它的取值是99，那么系统将花费不超过1/(1+n)的时间用于垃圾回收，也就是1/(1+99)=1%的时间。另外还可以指定-XX：+UseAdaptiveSizePolicy打开自适应模式，在这种模式下，新生代的大小、eden、from/to的比例，以及晋升老年代的对象的年龄参数将被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 老年代ParallelOldGC回收器也是一种多线程的回收器，和新生代的ParallelGC回收器一样，也是一种关注吞吐量的回收器，它使用标记压缩算法实现。-XX:+UseParallelOldGC进行设置-XX:+ParallelGCThreads也可以设置垃圾收集时的线程数量。 CMS回收器 CMS全称为：Current Mark Sweep意为并发标记清除，他使用的是标记清除法，主要关注系统的停顿时间。使用-XX:+UseConcMarkSweepGC进行设置使用-XX:+ConcGCThreads设置并发线程数量 CMS并不是独占的回收器，也就是说CMS回收的过程中，应用程序仍在不断的运行，又会有新的垃圾不断的产生，所以在使用CMS的过程中应该确保应用程序的内存足够用。CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阈值的时候开始回收，回收阈值可以用指定的参数进行配置，-XX:CMSInitiatingOccupancyFraction来指定，默认值为68，也就是说当老年代的空间使用率达到68%的时候，会执行CMS回收。如果内存使用率增长很快，在CMS执行的过程中，已经出现内存不足的情况，此时CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这会使应用程序中断，直到垃圾回收完成后才会正常工作。这个过程GC停顿的时间可能比较长，所以-XX:CMSInitiatingOccupancyFraction的设置要根据实际情况。 之前我们在学习算法的时候说过，标记清除法有个缺点就是内存碎片的问题，那么CMS有个参数设置-XX:+UseCMSCompactAtFullCollection可以使CMS回收完成之后进行一次碎片整理，-XX:CMSFullGCsBeforeCompaction参数可以设置进行多少次CMS回收之后对内存进行一次压缩。 G1回收器G1回收器(Garbage-First)是在jdk1.7中提出的垃圾回收器，从长期目标来看是为了取代CMS回收器，G1回收器拥有独特的垃圾回收策略，G1属于分代垃圾回收器，区分新生代和老年代，依然有eden和from/to区,并不要求整个eden区或新生代、老年代空间都连续，它使用的是分区算法。并行性： G1回收期间可多线程同时工作。并发性： G1拥有与应用程序交替执行的能力，部分工作可与应用程序同时执行，在整个GC期间不会完全阻塞应用程序。分代GC： G1依然是一个分代收集器，但是它是兼顾新生代和老年代一起工作的，之前的垃圾收集器或者在新生代工作或者在老年代工作，因此这是一个很大的不同。空间整理： G1在回收过程中，不会像CMS那样在若干次GC后进行碎片整理，G1采用有效复制对象的方式减少空间碎片。可预见性：由于分区的原因，G1可以只选取部分区域进行回收，缩小了回收的范围，提高了性能。使用-XX:+UseG1GC应用G1收集器使用-XX:MaxGCPauseMillis指定最大的停顿时间使用-XX:ParallelGCThreads设置并行回收的线程数量 配置Tomcat参数（一）使用串行垃圾回收器1234-XX:+PrintGCDetails -Xmx32m -Xms32m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseSerialGC-XX:PermSize=32m 测试结果显示吞吐量为:871.8/sec 87KB/sec 配置Tomcat参数（二）扩大内存提高系统性能12345-XX:+PrintGCDetails -Xmx512m -Xms32m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseSerialGC-XX:PermSize=32m-Xloggc:d:/gc.log 测试结果显示吞吐量为:1383.31/sec 138KB/sec 配置Tomcat参数（三）调整初始堆大小12345-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseSerialGC-XX:PermSize=32m-Xloggc:d:/gc.log 测试结果显示吞吐量为:1501.3/sec 149.8KB/sec 配置Tomcat参数（四）测试ParNew回收器的表现12345-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseParNewGC-XX:PermSize=32m-Xloggc:d:/gc.log 测试结果显示吞吐量为:2130/sec 212KB/sec 配置Tomcat参数（五）测试ParallelOldGC回收器的表现1234567-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseParallelGC-XX:+UseParallelOldGC-XX:ParallelGCThreads=8-XX:PermSize=32M-Xloggc:d:/gc.log 测试结果显示吞吐量为:2236/sec 223KB/sec 配置Tomcat参数（五）测试CMS回收器的表现123456-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseConcMarkSweepGC-XX:ConcGCThreads=8-XX:PermSize=32M-Xloggc:d:/gc.log 测试结果显示吞吐量为:1813/sec 181KB/sec 源码：https://github.com/zxiang179/JVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM]]></title>
      <url>%2F2017%2F04%2F25%2FJVM%2F</url>
      <content type="text"><![CDATA[JVMjava虚拟机的原理与概述虚拟机可分为系统虚拟机和程序虚拟机系统虚拟机对物理计算机仿真。程序虚拟机是对物理计算机的仿真。 JVM结构- 类加载子系统：负责从文件系统或者网络加载class信息，加载的信息存放在一款称之为方法区的内存空间。 方法区：存放类信息、常量信息、常量池信息、包括字符串字面量和数字常量等。 java堆：在JVM启动时建立java堆，它是java程序最主要的内存工作区域，几乎所有的对象实例都存放到java堆中，堆空间是所有线程共享的。 直接内存： java的NIO库允许java程序直接使用内存从而提高性能，通常直接内存速度会优于java堆。读写频繁的场合可能会考虑使用。 java栈：每个JVM都有一个私有的栈，一个线程的java栈在线程创建的时候就被创建，java栈中保存着局部变量、方法参数、同时java的方法调用、返回值等。 本地方法栈和java栈类似，最大的不同是本地方法栈用于本地方法调用。java虚拟机允许java直接调用本地方法。(通常使用C编写) 垃圾收集系统是java的核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无序手工清理。 PC（Program Counter）寄存器：是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任何时刻，一个java线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器会指向当前正在被执行的指令，如果是本地方法，则PC寄存器值为undefined，寄存器存放如当前执行环境指针，程序计数器，操作栈指针，计算的变量指针等信息。 执行引擎是JVM最核心的组件，它负责执行JVM的字节码，一般会先进行编译成字节码后执行。 堆栈方法区的概念及联系堆解决的是数据存储的问题，即数据怎么放，放在哪里。栈解决的是程序的运行问题，即程序如何执行，或者说如何处理数据。方法区是辅助堆栈的块永久区(Perm)，解决堆栈信息的产生，是先决条件。我们创建一个新的对象，User：那么User类的一些信息(类信息，静态信息都存在于方法区中)而User类被实例化出来之后被存放在java堆中，一块内存空间。当我们去使用的时候都是使用User对象的引用，形如User user=new User();这里的user就是存放在java栈中的，即User真实对象的一个引用。 辨清java堆java堆是和应用程序关系最密切的内存空间，几乎所有对象都存放在其中，并且java堆完全是自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显示的释放。根据垃圾回收机制不同，java堆可能有不同的结构。最为常见的就是将整个java堆分为新生代和老年代。其中新生代存放新生的对象或者年龄不大的对象，老年代则存放老年对象。新生代分为eden区、s0区、s1区，s0和s1也被称为from和to区域，它们是两块大小相等并且可以互换角色的空间。(复制算法)绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则会进入s0或者s1区，之后每经过一次新生代回收，如果对象存活，则它的年龄就加1，当对象达到一定年龄后，则进入老年代。 java栈java栈是一个线程私有的内存空间，一个栈一般由三个部分组成：局部变量表，操作数栈和帧数据区。局部变量表：用于报错函数的参数及局部变量。操作数栈：主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。帧数据区：除局部变量表和操作数栈，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便程序访问常量池。另外，当函数返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表也是帧数据区的一部分。 java方法区java方法区和堆一样，方法区是一个所有线程共享的内存区域，它保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少类。如果系统定义太多的类，导致方法区移除。java虚拟机同样会抛出内存溢出错误。方法区可以理解为永久区（Perm）。 源码：https://github.com/zxiang179/JVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F25%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
