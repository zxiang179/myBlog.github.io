<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Disruptor基础]]></title>
      <url>%2F2017%2F05%2F08%2FDisruptor%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[Disruptor Martin Fowler在自己网站上写了一篇LMAX架构的文章，在文章中他介绍了LMAX是一种新型零售金融交易平台，它能够以很低的延迟产生大量交易。这个系统是建立在JVM平台上，其核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。业务逻辑处理器的核心是Disruptor。 在Disruptor中，我们想实现hello world 需要如下几步骤： 第一：建立一个Event类 第二：建立一个工厂Event类，用于创建Event类实例对象 第三：需要有一个监听事件类，用于处理数据（Event类） 第四：我们需要进行测试代码编写。实例化Disruptor实例，配置一系列参数。然后我们对Disruptor实例绑定监听事件类，接受并处理数据。 第五：在Disruptor中，真正存储数据的核心叫做RingBuffer，我们通过Disruptor实例拿到它，然后把数据生产出来，把数据加入到RingBuffer的实例对象中即可。 Event类12345678910public class LongEvent &#123; private long value; public long getValue() &#123; return value; &#125; public void setValue(long value) &#123; this.value = value; &#125;&#125; EventFactory类12345678//需要让disruptor为我们创建事件，我们同时还声明了一个EventFactory来实例化Event对象public class LongEventFactory implements EventFactory&#123; @Override public Object newInstance() &#123; return new LongEvent(); &#125;&#125; EventHandler类123456789public class LongEventHandler implements EventHandler&lt;LongEvent&gt; &#123; @Override public void onEvent(LongEvent longEvent, long l, boolean b) throws Exception &#123; System.out.println(longEvent.getValue()); &#125;&#125; LongEventProducer类1234567891011121314151617181920212223242526272829303132333435363738/** * 很明显 当用一个简单队列来发布事件的时候会牵涉更多的细节，这是因为事件对象还需要预先创建。 * 发布事件最少需要两步：获取下一个事件槽并发布事件（发布事件的时候要使用try/finally保证事件一定被发布） * 如果我们使用RingBuffer.next()获取一个事件槽，那么一定要发布对应的事件。 * 如果不能发布事件，那么会引起Disruptor状态的混乱。 * 尤其是在多个事件生产者的情况下会导致事件消费者失速，从而不得不重启应用才能恢复。 * @author Carl_Hugo * */public class LongEventProducer &#123; private final RingBuffer&lt;LongEvent&gt; ringBuffer; public LongEventProducer(RingBuffer&lt;LongEvent&gt; ringBuffer)&#123; this.ringBuffer=ringBuffer;&#125; /** * onData用来发布事件，每调用一次就发布一次事件 * 它的参数会通过事件传递给消费者 * @param bb */ public void onData(ByteBuffer bb)&#123; //1 可以把ringBuffer看作一个事件队列那么next就是得到下一个事件槽 long sequence = ringBuffer.next(); try &#123; //2 用上面的一个索引取出一个空的事件用于填充(获取该序号对应的事件对象) LongEvent longEvent = ringBuffer.get(sequence); //3 获取要通过事件传递的业务数据 longEvent.setValue(bb.getLong(0)); &#125; finally&#123; //4 发布事件 //注意，最后的ringBuffer.publish方法必须包含在finally中以确保必须得到调用，如果某个请求的sequence未被提交 ringBuffer.publish(sequence); &#125; &#125;&#125; Main类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LongEventMain &#123; public static void main(String[] args) &#123; //创建缓冲区 ExecutorService executor = Executors.newCachedThreadPool(); //创建工厂 LongEventFactory factory = new LongEventFactory(); //创建bufferSize，也就是RingBuffer的大小，必须是2的N次方 int ringBufferSize = 1024*1024; /*//BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同的环境中能够提供更加一致的性能表现 WaitStrategy BLOCKING_WAIT = new BlockingWaitStrategy(); //SleepingWaitStrategy的性能表现和BlockingWaitStrategy差不多，对CPU消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类的场景。 WaitStrategy SLEEPING_WAIT = new SleepingWaitStrategy(); //YieldingWaitStrategy的性能最好，适用于低延迟的系统。在要求性能极高且时间处理线程数小于CPU逻辑线程数的场景中，推荐使用此策略：例如CPU开启超线程策略 WaitStrategy YIELD_WAIT = new YieldingWaitStrategy();*/ //创建Disruptor //1 第一个参数为工厂类对象，用于创建一个个的LongEvent，LongEvent是实际的消费数据 //2 第二个参数是缓冲区大小 //3 第三个参数是线程池，进行Disruptor内部的数据接受处理调度 //4 第四个参数ProducerType.SINGLE和ProducerType.MULTI //5 第五个参数是一种策略:WaitStrategy Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;LongEvent&gt;(factory, ringBufferSize, executor,ProducerType.SINGLE,new YieldingWaitStrategy()); //连接消费事件方法 disruptor.handleEventsWith(new LongEventHandler()); //启动 disruptor.start(); //Disruptor的事件发布有两个阶段提交的过程 //使用该方法获得具体存放数据的容器ringBuffer(环形结构) RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer(); LongEventProducer producer = new LongEventProducer(ringBuffer);// LongEventProducerWithTranslator producer = new LongEventProducerWithTranslator(ringBuffer); ByteBuffer byteBuffer = ByteBuffer.allocate(8); for(long a=0;a&lt;100;a++)&#123; byteBuffer.putLong(0,a); producer.onData(byteBuffer); &#125; disruptor.shutdown();//关闭Disruptor，方法会堵塞，知道所有的事件都得到处理 executor.shutdown();//关闭Disruptor使用的线程池：如果需要的话，必须手动关闭，Disruptor在shutdown时不会自动关闭。 &#125;&#125; LongEventProducerWithTranslator类12345678910111213141516171819202122public class LongEventProducerWithTranslator &#123; //一个translator可以看作一个事件的初始化器，publicEvent方法会调用它 //填充Event public static final EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt; TRANSLATOR = new EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt;() &#123; @Override public void translateTo(LongEvent event, long sequence,ByteBuffer buffer) &#123; event.setValue(buffer.getLong(0)); &#125; &#125;; private final RingBuffer&lt;LongEvent&gt; ringBuffer; public LongEventProducerWithTranslator(RingBuffer&lt;LongEvent&gt; ringBuffer)&#123; this.ringBuffer=ringBuffer; &#125; public void onData(ByteBuffer buffer)&#123; ringBuffer.publishEvent(TRANSLATOR,buffer); &#125;&#125; RingBuffer: 被看作Disruptor最主要的组件，然而从3.0开始RingBuffer仅仅负责存储和更新在Disruptor中流通的数据。对一些特殊的使用场景能够被用户(使用其他数据结构)完全替代。 ringbuffer到底是什么？答：嗯，正如名字所说的一样，它是一个环（首尾相接的环），你可以把它用做在不同上下文（线程）间传递数据的buffer。 基本来说，ringbuffer拥有一个序号，这个序号指向数组中下一个可用元素 随着你不停地填充这个buffer（可能也会有相应的读取），这个序号会一直增长，直到绕过这个环。 要找到数组中当前序号指向的元素，可以通过mod操作：sequence mod array length = array index（取模操作）以上面的ringbuffer为例（java的mod语法）：12 % 10 = 2。很简单吧。事实上，上图中的ringbuffer只有10个槽完全是个意外。如果槽的个数是2的N次方更有利于基于二进制的计算机进行计算。 ringbuffer的优点？ 因为它是数组，所以要比链表快，而且有一个容易预测的访问模式。 这是对CPU缓存友好的，也就是说在硬件级别，数组中的元素是会被预加载的，因此在ringbuffer当中，cpu无需时不时去主存加载数组中的下一个元素。 其次，你可以为数组预先分配内存，使得数组对象一直存在（除非程序终止）。这就意味着不需要花大量的时间用于垃圾回收。此外，不像链表那样，需要为每一个添加到其上面的对象创造节点对象—对应的，当删除节点时，需要执行相应的内存清理操作。 Sequence: Disruptor使用Sequence来表示一个特殊组件处理的序号。和Disruptor一样，每个消费者(EventProcessor)都维持着一个Sequence。大部分的并发代码依赖这些Sequence值的运转，因此Sequence支持多种当前为AtomicLong类的特性。Sequencer: 这是Disruptor真正的核心。实现了这个接口的两种生产者（单生产者和多生产者）均实现了所有的并发算法，为了在生产者和消费者之间进行准确快速的数据传递。SequenceBarrier: 由Sequencer生成，并且包含了已经发布的Sequence的引用，这些的Sequence源于Sequencer和一些独立的消费者的Sequence。它包含了决定是否有供消费者来消费的Event的逻辑。 WaitStrategy：决定一个消费者将如何等待生产者将Event置入Disruptor。EventProcessor：主要事件循环，处理Disruptor中的Event，并且拥有消费者的Sequence。它有一个实现类是BatchEventProcessor，包含了event loop有效的实现，并且将回调到一个EventHandler接口的实现对象。EventHandler：由用户实现并且代表了Disruptor中的一个消费者的接口。Producer：由用户实现，它调用RingBuffer来插入事件(Event)，在Disruptor中没有相应的实现代码，由用户实现。WorkProcessor：确保每个sequence只被一个processor消费，在同一个WorkPool中的处理多个WorkProcessor不会消费同样的sequence。WorkerPool：一个WorkProcessor池，其中WorkProcessor将消费Sequence，所以任务可以在实现WorkHandler接口的worker吃间移交。LifecycleAware：当BatchEventProcessor启动和停止时，于实现这个接口用于接收通知。 初看Disruptor，给人的印象就是RingBuffer是其核心，生产者向RingBuffer中写入元素，消费者从RingBuffer中消费元素，如下图： 源码 GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式]]></title>
      <url>%2F2017%2F05%2F04%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 静态代理简单实例Subject.java1234public interface Subject &#123; public void Request();&#125; RealSubject.java123456public class RealSubject implements Subject&#123; @Override public void Request() &#123; System.out.println(&quot;真实的请求&quot;); &#125;&#125; Proxy.java12345678910public class Proxy implements Subject&#123; RealSubject realSubject; @Override public void Request() &#123; if(realSubject==null)&#123; realSubject=new RealSubject(); &#125; realSubject.Request(); &#125;&#125; 通过代理实现realSubject的发送请求Test.java123456public class Test &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.Request(); &#125;&#125; 具体实例(追求者通过代理赠送礼物)SchoolGirl.java123456789public class SchoolGirl &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; GiveGift.java123456public interface GiveGift &#123; void giveDolls(); void giveFlowers(); void giveChocolate();&#125; Pursuit.java1234567891011121314151617181920212223public class Pursuit implements GiveGift&#123; public SchoolGirl mm; public Pursuit(SchoolGirl mm)&#123; this.mm=mm; &#125; @Override public void giveDolls() &#123; System.out.println(mm.getName()+&quot;送你洋娃娃&quot;); &#125; @Override public void giveFlowers() &#123; System.out.println(mm.getName()+&quot;送你鲜花&quot;); &#125; @Override public void giveChocolate() &#123; System.out.println(mm.getName()+&quot;送你巧克力&quot;); &#125;&#125; Proxy.java12345678910111213141516171819202122public class Proxy implements GiveGift&#123; Pursuit gg; public Proxy(SchoolGirl mm)&#123; gg=new Pursuit(mm); &#125; @Override public void giveDolls() &#123; gg.giveDolls(); &#125; @Override public void giveFlowers() &#123; gg.giveFlowers(); &#125; @Override public void giveChocolate() &#123; gg.giveChocolate(); &#125;&#125; 当Pursuit对象无法之间完成giveDolls()、giveFlowers()、giveChocolate()方法时，通过创建代理对象，由代理对象创建new pursuit(),并通过pursuit对象实现方法的调用。 分析：通过这里例子以及扩展我们来看一下静态代理模式的缺点吧： 如果出现上面的需求，那么势必会出现类爆炸的结果； 当然捕捉方法执行时间的代码都一样，我们每个方法都写，每个类都写，这也是代码的重复，没有达到代码复用的效果，这也完全违背了面向对象设计的原则。 思考：防止出现类爆炸，使代码能够得到复用。我们能不能用一个代理类，来代理所有需要的类。 动态代理模式 通过反射机制，利用JDK提供的Proxy类，在程序运行的时候在内存中根据目标对象来创建代理对象，避免了类爆炸的出现。 使用代理模式必须要让代理类和目标类实现相同的接口，客户端通过代理类来调用目标方法，代理类会将所有的方法调用分派到目标对象上反射执行，还可以在分派过程中添加”前置通知”和后置处理（如在调用目标方法前校验权限，在调用完目标方法后打印日志等）等功能。 代理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 此类需要实现InvocationHandler接口 * 调用处理器，当代理对象调用代理方法的时候，注册在调用处理器中的invoke方法会自动调用 * @author Carl_Hugo * @date 2017年5月4日 */public class MyInvocationHandler implements InvocationHandler&#123; //目标对象，通过反射机制获得 private Object target; //构造方法 public MyInvocationHandler(Object target) &#123; super(); this.target=target; &#125; /** * 执行目标对象的方法 * 参数：Object proxy 代理对象的引用，proxy变量中保存代理对象的内存地址 * Method method 目标对象的目标方法 * Object[] args:目标对象的目标方法执行的时候需要实参 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //开始时间 long begin = System.currentTimeMillis(); System.out.println(&quot;==============开始==============&quot;); //执行目标对象中的方法 Object retValue = method.invoke(target, args); //结束时间 long end = System.currentTimeMillis(); //计算时间 System.out.println(&quot;==============结束==============&quot;); System.out.println(&quot;耗费时长：&quot;+(end-begin)+&quot;ms&quot;); return retValue; &#125; /** * 获取目标对象的代理对象 * @return */ public Object getProxy()&#123; return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), this); &#125;&#125; 测试类12345678910111213141516171819202122/** * 注意：JDK内置的动态代理Proxy只能代理接口 * (如果既想代理接口又想代理抽象类需要使用第三方组件：例如cglib) * @author Carl_Hugo * @date 2017年5月4日 */public class Test &#123; public static void main(String[] args) &#123; //实例化目标对象 UserService userService = new UserServiceImpl(); //实例化MyInvocationHandler MyInvocationHandler invocationHandler = new MyInvocationHandler(userService); //根据目标对象创建代理对象 UserService proxy = (UserService)invocationHandler.getProxy(); /*UserService proxy = (UserService)Proxy.newProxyInstance(UserService.class.getClassLoader(), new Class[]&#123;UserService.class&#125;, invocationHandler);*/ //执行代理对象的方法 proxy.add(); &#125;&#125; UserService类12345public interface UserService &#123; public abstract void add(); &#125; UserServiceImpl类12345678public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;----------add-------------&quot;); &#125;&#125; 源码：https://github.com/zxiang179/DesignPattern]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工厂方法模式]]></title>
      <url>%2F2017%2F05%2F04%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[工厂方法模式（Factory Method）：定义一个创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。 Operation.java123456789101112131415161718192021222324252627282930313233343536373839404142public interface Operation &#123; public double getResult(double number1,double number2) throws Exception;&#125;class OperationAdd implements Operation&#123; @Override public double getResult(double number1, double number2) &#123; double result=0; return result=number1+number2; &#125;&#125;class OperationSub implements Operation&#123; @Override public double getResult(double number1, double number2) &#123; double result=0; return result=number1-number2; &#125;&#125;class OperationMul implements Operation&#123; @Override public double getResult(double number1, double number2) &#123; double result=0; return result=number1*number2; &#125;&#125;class OperationDiv implements Operation&#123; @Override public double getResult(double number1, double number2) throws Exception &#123; double result=0; if(number2==0)&#123; throw new Exception(&quot;除数不能为0&quot;); &#125; result=number1/number2; return result; &#125;&#125; 先构造一个工厂接口，然后加减乘除各自建造一个具体工厂去实现这个接口12345678910111213141516171819202122232425262728293031public interface IFactory &#123; Operation createOperation();&#125;class AddFactory implements IFactory&#123; @Override public Operation createOperation() &#123; return new OperationAdd(); &#125;&#125;class SubFactory implements IFactory&#123; @Override public Operation createOperation() &#123; return new OperationSub(); &#125;&#125;class MulFactory implements IFactory&#123; @Override public Operation createOperation() &#123; return new OperationMul(); &#125;&#125;class DivFactory implements IFactory&#123; @Override public Operation createOperation() &#123; return new OperationDiv(); &#125;&#125; Test.java12345678910package zx.factorymethod.test1;public class Test &#123; public static void main(String[] args) throws Exception &#123; AddFactory addFactory = new AddFactory(); Operation operationAdd = addFactory.createOperation(); System.out.println(operationAdd.getResult(1, 1)); &#125;&#125; 工厂方法模式实现时，客户端需要决定实例化哪个工厂来实现运算类。也就是说，工厂方法模式把简单工厂的内部逻辑判断移到客户端代码来进行。如果想要加功能，本来是改工厂，现在是修改客户端。 具体实例(雷锋/志愿者工厂)简单工厂 简单工厂：根据传入的参数返回特定的对象。1234567891011121314151617public class LeiFeng &#123; public void Sweep()&#123; System.out.println(&quot;扫地&quot;); &#125; public void Wash()&#123; System.out.println(&quot;洗衣&quot;); &#125; public void BuyRice()&#123; System.out.println(&quot;买米&quot;); &#125;&#125;class UnderGraduate extends LeiFeng&#123;&#125;class Volunteer extends LeiFeng&#123;&#125; 工厂方法 工厂方法：根据创建的工厂类型，返回特定的对象 雷锋工厂IFactory.java1234567891011121314151617public interface IFactory &#123; LeiFeng createLeiFeng();&#125;class UnderGraduateFactory implements IFactory&#123; @Override public LeiFeng createLeiFeng() &#123; return new UnderGraduate(); &#125;&#125;class VolunteerFactory implements IFactory&#123; @Override public LeiFeng createLeiFeng() &#123; return new Volunteer(); &#125;&#125; IFactory为工厂接口，UnderGraduateFactory和VolunteerFactory为实现这个接口的具体工厂的实现。 工厂方法模式的调用Test.java123456789public class Test &#123; public static void main(String[] args) &#123; IFactory underGraduateFactory = new UnderGraduateFactory(); LeiFeng leiFeng = underGraduateFactory.createLeiFeng(); leiFeng.Sweep(); leiFeng.BuyRice(); leiFeng.Wash(); &#125;&#125; 工厂方法模式的使用场合 客户端不知道它要创建的具体是哪一个子类。 一个类想要由自己的子类来定义某对象的创建过程。 类将创建某对象的职责代理给一些帮助子类中的一个，并且你想要将哪-一个子类作为代理的信息进行局部化。 源码：https://github.com/zxiang179/DesignPattern]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单工厂模式]]></title>
      <url>%2F2017%2F05%2F04%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[简单的工厂模式:通过加载传入的字符串，返回所需特定的实现类创建的对象 接口Operation及其各种的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package zx.simplefactorypattern.test1;public interface Operation &#123; public double getResult(double number1,double number2) throws Exception; // public abstract double getResult(double... number1) throws Exception; &#125;class OperationAdd implements Operation&#123; @Override public double getResult(double number1, double number2) &#123; double result=0; return result=number1+number2; &#125;&#125;class OperationSub implements Operation&#123; @Override public double getResult(double number1, double number2) &#123; double result=0; return result=number1-number2; &#125;&#125;class OperationMul implements Operation&#123; @Override public double getResult(double number1, double number2) &#123; double result=0; return result=number1*number2; &#125;&#125;class OperationDiv implements Operation&#123; @Override public double getResult(double number1, double number2) throws Exception &#123; double result=0; if(number2==0)&#123; throw new Exception(&quot;除数不能为0&quot;); &#125; result=number1/number2; return result; &#125;&#125; 对象工厂 123456789101112131415package zx.simplefactorypattern.test1;public class OperationFactory &#123; public static Operation createOperation(String operate)&#123; Operation opera=null; switch(operate)&#123; case &quot;+&quot;: opera=new OperationAdd(); break; case &quot;-&quot;: opera=new OperationSub(); break; case &quot;*&quot;: opera=new OperationMul(); break; case &quot;/&quot;: opera=new OperationDiv(); break; &#125; return opera; &#125;&#125; 测试 123456789101112131415161718package zx.simplefactorypattern.test1;public class Test1 &#123; public static void main(String[] args) throws Exception &#123; Operation operationAdd = new OperationFactory().createOperation(&quot;+&quot;); Operation operationSub = new OperationFactory().createOperation(&quot;-&quot;); Operation operationMul = new OperationFactory().createOperation(&quot;*&quot;); Operation operationDiv = new OperationFactory().createOperation(&quot;/&quot;); double n1=123; double n2=0; System.out.println(operationAdd.getResult(n1, n2)); System.out.println(operationSub.getResult(n1, n2)); System.out.println(operationMul.getResult(n1, n2)); System.out.println(operationDiv.getResult(n1, n2)); &#125;&#125; 通过简单工厂模式加载以ini结尾的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243/*工厂设计模式就是用于产生对象的。*/public class Demo1 &#123; public static void main(String[] args) throws Exception &#123; Person p = (Person) getInstance(); System.out.println(p); &#125; //需求： 编写一个简单工厂根据配置文件中对应类名返回对应的对象。 public static Object getInstance() throws Exception&#123; //读取配置文件 BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;f:/info.txt&quot;)); //读取第一行 : 读取类文件的信息 String className = bufferedReader.readLine(); //通过完整类名获取对应 的Class对象 Class clazz = Class.forName(className); //获取到对应的构造方法 Constructor constructor = clazz.getDeclaredConstructor(null); constructor.setAccessible(true); Object o = constructor.newInstance(null); //给对象设置对应的属性值 String line = null; while((line = bufferedReader.readLine())!=null)&#123; String[] datas = line.split(&quot;=&quot;); Field field =clazz.getDeclaredField(datas[0]); //设置可以访问 field.setAccessible(true); if(field.getType()==int.class)&#123; field.set(o, Integer.parseInt(datas[1])); &#125;else&#123; field.set(o, datas[1]); &#125; &#125; return o; &#125; &#125; info.txt123reflect.Personid=110name=旺财 适用于哪些场景1.工厂类负责创建的对象比较少；2.客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；3.由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。 源码：https://github.com/zxiang179/DesignPattern]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[观察者设计模式]]></title>
      <url>%2F2017%2F05%2F04%2F%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者设计模式：又被称作是发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个对象的状态发生变化时，会通知所有的观察者对象，使他们能够自动更新自己。 解决的问题：将系统分割成一些类或者相互协作的类，会有一个不好的副作用。那就是需要维护相关对象的一致性。我们不希望为了维护一致性而使得各种类紧密耦合，这样会给维护扩展重用都带来不便。观察者就是解决这一类问题的。 典型的观察者设计模式(双向耦合)Secretary.java-通知类 12345678910111213141516171819202122232425public class Secretary &#123; //同事列表 private List&lt;StockObserver&gt; observers=new ArrayList&lt;StockObserver&gt;(); private String action; //增加 public void attach(StockObserver observer)&#123; observers.add(observer); &#125; public void inform()&#123; for(StockObserver s:observers)&#123; s.update(); &#125; &#125; //前台状态 public String SecretaryAction; public String getSecretaryAction() &#123; return SecretaryAction; &#125; public void setSecretaryAction(String secretaryAction) &#123; SecretaryAction = secretaryAction; &#125;&#125; StockObserver.java-订阅类 123456789101112131415public class StockObserver &#123; private String name; private Secretary sub; public StockObserver(String name,Secretary sub)&#123; this.name=name; this.sub=sub; &#125; public void update() &#123; System.out.println(sub.SecretaryAction+&quot; &quot;+name+&quot; 关闭股票行情，继续努力工作&quot;); &#125;&#125; 测试12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; //前台 Secretary secretary = new Secretary(); //看股票的同事 StockObserver stockObserver1 = new StockObserver(&quot;张三&quot;,secretary); StockObserver stockObserver2 = new StockObserver(&quot;李四&quot;,secretary); //前台记录下两位同事 secretary.attach(stockObserver1); secretary.attach(stockObserver2); secretary.setSecretaryAction(&quot;Boss回来了！！！&quot;); secretary.inform(); &#125;&#125; 输出 典型的观察者设计模式(抽象观察者和订阅者)Subject.java-抽象通知类 12345678910111213141516public abstract class Subject &#123; abstract void attach(Observer observer); abstract void detach(Observer observer); abstract void inform(); protected String subjectState; public String getSubjectState() &#123; return subjectState; &#125; public void setSubjectState(String subjectState) &#123; this.subjectState = subjectState; &#125;&#125; Boss.java-具体通知类 123456789101112131415161718192021222324public class Boss extends Subject&#123; //同事列表 //private 只有当前类可以访问 private List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;(); private String action; @Override public void attach(Observer observer) &#123; observers.add(observer); &#125; @Override public void detach(Observer observer) &#123; observers.remove(observer); &#125; @Override public void inform() &#123; for(Observer o:observers)&#123; o.update(); &#125; &#125;&#125; Observer.java-抽象订阅者 12345678910111213public abstract class Observer &#123; //protected 同一个包中可以访问，继承的子类可以访问 protected String name; protected Subject sub; public abstract void update(); public Observer(String name,Subject sub)&#123; this.name=name; this.sub=sub; &#125;&#125; NBAObserver.java-具体订阅者 1234567891011public class NBAObserver extends Observer&#123; public NBAObserver(String name, Subject sub) &#123; super(name, sub); &#125; @Override public void update() &#123; System.out.println(sub.getSubjectState()+&quot; &quot;+name+&quot; 关闭NBA直播继续工作！！！&quot;); &#125;&#125; StockObserver.java-具体订阅者 1234567891011public class StockObserver extends Observer&#123; public StockObserver(String name, Subject sub) &#123; super(name, sub); &#125; @Override public void update() &#123; System.out.println(sub.getSubjectState()+&quot; &quot;+name+&quot; 关闭股票行情继续工作！！！&quot;); &#125;&#125; 测试 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; Subject boss = new Boss(); Observer observer1 = new NBAObserver(&quot;张三&quot;,boss); Observer observer2 = new StockObserver(&quot;李四&quot;,boss); boss.attach(observer1); boss.attach(observer2); boss.setSubjectState(&quot;我胡汉三回来了！&quot;); boss.inform(); &#125;&#125; 输出 观察者设计模式：观察者设计模式解决的问题时当一个对象发生指定的动作时，要通过另外一个对象做出相应的处理。 需求： 编写一个气象站、一个工人两个类，当气象站更新天气 的时候，要通知人做出相应的处理。 问题1： 气象站更新了多次天气，然后人才做一次的处理。 问题2： 目前气象站只能通知一个人而已。 问题3： 在现实生活中出了工人群体要关注天气，其他 的群体也需要关注天气 观察者设计模式的步骤： 1. 当前目前对象发生指定的动作是，要通知另外一个对象做出相应的处理，这时候应该把对方的相应处理方法定义在接口上。 2. 在当前对象维护接口的引用，当当前对象发生指定的动作这时候即可调用接口中的方法了。 1234567891011121314151617181920212223242526272829//人 是要根据天气做出相应的处理的。public class Emp implements Weather&#123; String name; public Emp(String name) &#123; this.name = name; &#125; //人是要根据天气做出相应的处理的。 &quot;晴天&quot;,&quot;雾霾&quot;,&quot;刮风&quot;,&quot;冰雹&quot;,&quot;下雪&quot; public void notifyWeather(String weather)&#123; if(&quot;晴天&quot;.equals(weather))&#123; System.out.println(name+&quot;高高兴兴的去上班!!&quot;); &#125;else if(&quot;雾霾&quot;.equals(weather))&#123; System.out.println(name+&quot;戴着消毒面具去上班!&quot;); &#125;else if(&quot;刮风&quot;.equals(weather))&#123; System.out.println(name+&quot;拖着大石头过来上班!&quot;); &#125;else if(&quot;冰雹&quot;.equals(weather))&#123; System.out.println(name+&quot;戴着头盔过来上班!&quot;); &#125;else if(&quot;下雪&quot;.equals(weather))&#123; System.out.println(name+&quot;戴着被子过来上班!&quot;); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728public class Student implements Weather&#123; String name; public Student(String name) &#123; super(); this.name = name; &#125; public void notifyWeather(String weather)&#123; if(&quot;晴天&quot;.equals(weather))&#123; System.out.println(name+&quot;高高兴兴的去开学!!&quot;); &#125;else if(&quot;雾霾&quot;.equals(weather))&#123; System.out.println(name+&quot;吸多两口去上学!&quot;); &#125;else if(&quot;刮风&quot;.equals(weather))&#123; System.out.println(name+&quot;在家睡觉!&quot;); &#125;else if(&quot;冰雹&quot;.equals(weather))&#123; System.out.println(name+&quot;在家睡觉!&quot;); &#125;else if(&quot;下雪&quot;.equals(weather))&#123; System.out.println(name+&quot;等下完再去上学!&quot;); &#125; &#125; &#125; 12345//订阅天气预报的接口public interface Weather &#123; public void notifyWeather(String weather);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//气象站public class WeatherStation &#123; String[] weathers = &#123;&quot;晴天&quot;,&quot;雾霾&quot;,&quot;刮风&quot;,&quot;冰雹&quot;,&quot;下雪&quot;&#125;; //当前天气 String weather ; //该集合中存储的都是需要收听天气预报的人 ArrayList&lt;Weather&gt; list = new ArrayList&lt;Weather&gt;(); //程序设计讲究低耦合----&gt;尽量不要让一个类过分依赖于另外一个类。 public void addListener(Weather e)&#123; list.add(e); &#125; //开始工作 public void startWork() &#123; final Random random = new Random(); new Thread()&#123; @Override public void run() &#123; while(true)&#123; updateWeather(); // 每1~1.5秒更新一次天气 1000~1500 for(Weather e : list)&#123; e.notifyWeather(weather); &#125; int s = random.nextInt(501)+1000; // 500 try &#123; Thread.sleep(s); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; //更新天气的 方法 public void updateWeather()&#123; Random random = new Random(); int index = random.nextInt(weathers.length); weather = weathers[index]; System.out.println(&quot;当前的天气是： &quot; + weather); &#125; &#125; 1234567891011121314151617181920212223public class WeatherMain &#123; public static void main(String[] args) throws Exception &#123; //工人 Emp e = new Emp(&quot;小明&quot;); Emp e2 = new Emp(&quot;如花&quot;); //学生 Student s1 = new Student(&quot;狗娃&quot;); Student s2 = new Student(&quot;狗剩&quot;); WeatherStation station = new WeatherStation(); station.addListener(e); station.addListener(e2); station.addListener(s1); station.addListener(s2); station.startWork(); &#125; &#125; 观察者模式多用于实现订阅功能的场景，例如微博的订阅，当我们订阅了某个人的微博账号，当这个人发布了新的消息，就会通知我们。 源码：https://github.com/zxiang179/DesignPattern]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM参数配置]]></title>
      <url>%2F2017%2F05%2F03%2FJVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[虚拟机参数在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排除会有一定的帮助，为此，虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行java虚拟机，就可以在系统运行是打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实主要就是围绕着堆栈方法区配置。 堆分配参数-XX:+PrintGC :使用这个参数，虚拟机启动后只要遇到GC就会打印日志。-XX:+UseSerialGC :配置串行回收器。-XX:+PrintGCDetails: 可以查看详细信息，包括各个区的情况。-Xms:设置java程序启动时的初始堆大小。-Xmx:设置java程序能获得最大堆的大小-Xmx20m -Xms5m -XX:+PrintCommandLineFlags:可以将隐式或显示传给虚拟机的参数输出。总结：在实际工作中，我们可以直接将初始堆的大小和最大堆大小设置相等，这样的好处是可以减少运行时的垃圾回收次数，从而提高性能。 123456789101112131415161718192021222324252627282930313233public class Test01 &#123; public static void main(String[] args) &#123; //-XX:+PrintGC -Xms5m -Xmx20m -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintCommandLineFlags //1: //-XX:+PrintGC -Xms5m -Xmx20m -XX:+UseSerialGC -XX:+PrintGCDetails //查看GC信息 System.out.println(&quot;max memory:&quot;+Runtime.getRuntime().maxMemory()); System.out.println(&quot;free memory:&quot;+Runtime.getRuntime().freeMemory()); System.out.println(&quot;total memory:&quot;+Runtime.getRuntime().totalMemory()); byte[] b1 = new byte[1*1024*1024]; System.out.println(&quot;分配了1M&quot;); System.out.println(&quot;max memory:&quot;+Runtime.getRuntime().maxMemory()); System.out.println(&quot;free memory:&quot;+Runtime.getRuntime().freeMemory()); System.out.println(&quot;total memory:&quot;+Runtime.getRuntime().totalMemory()); byte[] b2 = new byte[4*1024*1024]; System.out.println(&quot;分配了4M&quot;); System.out.println(&quot;max memory:&quot;+Runtime.getRuntime().maxMemory()); System.out.println(&quot;free memory:&quot;+Runtime.getRuntime().freeMemory()); System.out.println(&quot;total memory:&quot;+Runtime.getRuntime().totalMemory()); int a = 0x00000000fee10000; int b = 0x00000000fec00000; System.out.println(&quot;结果为1920k，但实际结果：&quot;+(a-b)/1024); &#125;&#125; 堆分配参数（二）-Xmn:可以设置新生代的大小，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，新生代大小一般会设置整个堆空间的1/3到1/4左右。-XX:SurvivorRatio:用来设置新生代中eden空间和from/to空间的比例。含义：-XX:SurvivorRatio=eden/from=eden/to总结：不同的堆分布情况，对系统的执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能的将对象预留在新生代，减少老年代的GC次数。除了可以设置新生代的绝对大小(-Xmn),还可以使用(-XX:NewRation)设置新生代和老年代的比例：-XX:newRatio=老年代/新生代 123456789101112131415161718192021public class Test02 &#123; public static void main(String[] args) &#123; //第一次配置 eden 2 =from 1+ to 1 //-Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC //第二次配置 //-Xms20m -Xmx20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC //第三次配置 //-XX:NewRatio=老年代/新生代 //-Xms20m -Xmx20m -XX:NewRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC byte[] b=null; //连续向系统申请10m空间 for(int i=0;i&lt;10;i++)&#123; b=new byte[1*1024*1024]; &#125; &#125; &#125; 堆溢出处理在java程序运行的过程中，如果堆空间不足，则会抛出内存溢出的错误(Out Of Memory),一旦这类问题发生在生产环境，可能引起严重的业务中断，java虚拟机提供了-XX:+HeapDumpOnOutOfMemoryError,使用该参数可以在内存溢出时导出整个堆信息，与之配合的还有参数，-XX:HeapDumpPath,可以设置导出堆的路径。内存分析工具：Memory Analyzer 1.5.0 123456789101112public class Test3 &#123; public static void main(String[] args) &#123; //-Xms2m -Xmx2m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=e:/Test03.dump //堆内存溢出 Vector vector = new Vector(); for(int i=0;i&lt;5;i++)&#123; vector.add(new Byte[1*1024*1024]); &#125; &#125;&#125; 栈配置Java虚拟机提供了参数-Xss来指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大深度。 12345678910111213141516171819202122public class Test4 &#123; //-Xss1m //-Xss5m //栈调用深度 private static int count; public static void recursion()&#123; count++; recursion(); &#125; public static void main(String[] args) &#123; try &#123; recursion(); &#125; catch (Throwable e) &#123; System.out.println(&quot;调用最大深处：&quot;+count); e.printStackTrace(); &#125; &#125;&#125; 方法区和java堆一样，方法区是一块所有线程共享的内存区域，它用于保存系统的类信息，方法区(永久区)可以保存多少信息可以对其进行配置，在默认情况下，-XX:MaxPermSize为64MB，如果系统运行时产生大量的类，就需要设置一个相对合适的方法区，以免出现永久区内存溢出的问题。-XX:PermSize=64M -XX:MaxPermSize=64M 直接内存配置直接内存也是java程序中非常重要的组成部分，特别是广泛用在NIO中，直接内存跳过了java堆，使java程序可以直接访问原生堆空间，因此在一定的程度上加快了内存空间的访问速度。但是说直接内存一定就可以提高内存访问速度也不见得，具体问题具体分析。相关配置参数：-XX:MaxDirectMemorySize,如果不设置默认值为最大空间，即-Xmx。直接内存使用达到上限时，就会触发垃圾回收，如果不能有效的释放空间，也会引起系统的OOM。 Client和Server虚拟机的工作模式java虚拟机支持Client和Server模式，使用-client可以指定使用Client模式，使用-server可以使用Server模式。（jdk1.7及以后不需要考虑）区别：client模式比server模式启动要快，但长期运行server模式性能远远好于Client模式。 JVM博客：http://www.cnblogs.com/redcreen/tag/jvm/ 源码：https://github.com/zxiang179/JVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[垃圾回收/TomcatGC参数配置]]></title>
      <url>%2F2017%2F05%2F03%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8CTomcatGC%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[垃圾回收垃圾回收有很多种算法，如引用计数法，标记压缩法、复制算法、分带、分区的思想。 引用计数法这是一个比较古老而经典的垃圾回收算法，其核心是在对象被其他所引用时计数器加1，而当引用失效时则减一，但这种方法有非常严重的问题，无法处理循环引用的问题，还有就是每次进行加减操作比较浪费系统性能。 标记清除法就是分别标记和清除两个阶段进行处理内存中的对象，当然这种方式也有很大的弊端，就是空间碎片问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。 复制算法（新生代）其核心思想将内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的残留对象复制到未被使用的内存块中，之后去清除之前正在使用的内存块中所有的对象，反复去交换两个内存的角色，完成垃圾回收。（java中新生代的from和to空间就是使用了这个算法） 标记压缩法（老年代）标记压缩法在标记清除法基础上做了优化，把存活的对象压缩到内存的一端，而后进行垃圾清理。 为什么新生代和老年代使用不同的算法？新生代对象被回收的几率要大于老年代中对象被回收的概率，老年代中的对象都较为稳定。采用不同的算法是为了性能优化考虑。 分代算法根据对象的特点即将内存分为N块，而后根据内存的特点使用不同的算法。对于新生代和老生代来说，新生代回收频率较高，但是每次回收耗时都很短，而老年代回收频率较低，但是耗时会相对较长，所以应该尽量减少老年代的GC。 分区算法分区算法：其主要就是将整个内存分为N多个独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收多个小空间而不是针对整个空间进行GC，从而提升性能，并减少GC的停顿时间。 垃圾回收时的停顿现象垃圾回收的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以更高效的执行，大部分情况下，会要求系统进如一个停顿的状态。停顿的目的是为了终止所有的应用线程，只有这样的系统才不会有新垃圾的产生。同时停顿保证了系统状态在某一个瞬间的一致性，也有利于更好的标记垃圾对象。因此在垃圾回收时，都会产生应用程序的停顿。 对象如何进入老年代一般而言对象首次创建会被放置在新生代的eden区，如果没有GC介入，则对象不会离开eden区，那么eden区的对象如何进入老年代那呢？一般来说只要对象的年龄达到一定的大小，就会自动离开年轻代进入老年代，对象年龄是由对象经历数次GC决定的，在新生代每次GC后，如果没有被回收则年龄加1.虚拟机提供一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代-XX:MaxTenuringThreshold 1234567891011121314151617181920public class Test5 &#123; public static void main(String[] args) &#123; //初始对象在eden区 //-Xmx64m -Xms64m -XX:+PrintGCDetails /*for(int i=0;i&lt;5;i++)&#123; byte[] b = new byte[1024*1024]; &#125;*/ //测试进入老年代的对象 //-Xmx1024m -Xms1024m -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 -XX:+PrintGCDetails //-XX:+PrintHeapATGC for(int k=0;k&lt;20;k++)&#123; for(int j=0;j&lt;300;j++)&#123; byte[] b=new byte[1024*1024]; &#125; &#125; &#125;&#125; 总结：根据设置MaxTenuringThreshold参数可以指定新生代对象经过多少次回收后进入老年代。另外，大对象(新生代eden区无法装入时，也会直接进入老年代)。JVM有个参数可以设置对象的大小超过指定的大小之后，直接晋升老年代。-XX:PretenureSizeThreshold TLABTLAB全称是Thread Local Allocation Buffer即本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。每一个线程会产生一个TLAB，该线程独享的一个工作区域，java虚拟机使用这种TLAB来避免多线程冲突问题。提高了对象分配的效率。TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配在堆上。-XX:+UseTLAB 使用TLAB-XX:+TLABSize设置TLAB大小-XX:TLABRefillWasterFraction 设置维护进入TLAB空间的单个对象大小，它是一个比例值，默认64，即如果对象大于整个空间的1/64,则在堆创建对象。-XX:+PrintTLAB查看TLAB信息-XX:ResizeTLAB自调整TLABRefillWasteFraction阈值。每个线程单独的一块工作内存(volatile) 123456789101112131415161718public class Test7 &#123; public static void alloc()&#123; byte[] b = new byte[2]; &#125; public static void main(String[] args) &#123; //TLAB分配 //-XX:+UseTLAB -XX:+PrintTLAB -XX:TLABSize=102400 -XX:TLABRefillWasteFraction=100 -XX:-DoEscapeAnalysis long start = System.currentTimeMillis(); for(int i=0;i&lt;10000000;i++)&#123; alloc(); &#125; long end = System.currentTimeMillis(); System.out.println(end-start); &#125;&#125; 对象的创建流程图 垃圾收集器在java虚拟机中，垃圾回收器不仅仅只有一种，什么情况下该使用哪种，对性能又有什么影响，这些都是我们需要了解的。 串行垃圾收集器串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程，对于并行能力较弱的计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。串行回收器可以在新生代和老年代使用。根据作用于不同的对空间分为新生代串行回收器和老年代串行回收器。-XX：+UseSerialGC参数可以设置使用新生代串行回收器和老年代串行回收器。 并行垃圾收集器并行的垃圾回收器在串行回收器的基础上做了改进，他可以使用多个线程同时进行垃圾回收，对于计算能力强的计算机而言，可以有效的缩短垃圾回收所需的实际时间。 ParNew回收器是一个工作在新生代的垃圾回收器，他只是简单的将串行回收器多线程化，它的回收策略和算法和串行回收器一样。使用-XX:+UseParNewGC 新生代使用ParNew回收器，老年代则使用串行回收器。ParNew回收器工作时的线程数量可以使用-XX：ParallelGCThreads参数指定，一般最好和计算机的CPU相当，避免过多的线程影响性能。 新生代ParallelGC回收器，使用了复制算法的回收器，也是多线程独占形式的回收器，但ParallelGC回收器有一个很重要的特点，就是它非常关注吞吐量。提供了两个参数控制系统的吞吐量-XX: MaxGCPauseMillis:设置最大垃圾收集停顿时间，可用于把虚拟机在GC停顿的时间控制在MaxGCPauseMillis范围内，如果希望减少GC停顿时间可以将MaxGCPauseMillis设置的很小，但是会导致GC频繁，从而增加GC的总时间，降低了吞吐量。所以要根据实际情况设置该值。-XX: GCTimeRatio:设置吞吐量的大小，它是一个0到100之间的整数，默认情况下它的取值是99，那么系统将花费不超过1/(1+n)的时间用于垃圾回收，也就是1/(1+99)=1%的时间。另外还可以指定-XX：+UseAdaptiveSizePolicy打开自适应模式，在这种模式下，新生代的大小、eden、from/to的比例，以及晋升老年代的对象的年龄参数将被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 老年代ParallelOldGC回收器也是一种多线程的回收器，和新生代的ParallelGC回收器一样，也是一种关注吞吐量的回收器，它使用标记压缩算法实现。-XX:+UseParallelOldGC进行设置-XX:+ParallelGCThreads也可以设置垃圾收集时的线程数量。 CMS回收器 CMS全称为：Current Mark Sweep意为并发标记清除，他使用的是标记清除法，主要关注系统的停顿时间。使用-XX:+UseConcMarkSweepGC进行设置使用-XX:+ConcGCThreads设置并发线程数量 CMS并不是独占的回收器，也就是说CMS回收的过程中，应用程序仍在不断的运行，又会有新的垃圾不断的产生，所以在使用CMS的过程中应该确保应用程序的内存足够用。CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阈值的时候开始回收，回收阈值可以用指定的参数进行配置，-XX:CMSInitiatingOccupancyFraction来指定，默认值为68，也就是说当老年代的空间使用率达到68%的时候，会执行CMS回收。如果内存使用率增长很快，在CMS执行的过程中，已经出现内存不足的情况，此时CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这会使应用程序中断，直到垃圾回收完成后才会正常工作。这个过程GC停顿的时间可能比较长，所以-XX:CMSInitiatingOccupancyFraction的设置要根据实际情况。 之前我们在学习算法的时候说过，标记清除法有个缺点就是内存碎片的问题，那么CMS有个参数设置-XX:+UseCMSCompactAtFullCollection可以使CMS回收完成之后进行一次碎片整理，-XX:CMSFullGCsBeforeCompaction参数可以设置进行多少次CMS回收之后对内存进行一次压缩。 G1回收器G1回收器(Garbage-First)是在jdk1.7中提出的垃圾回收器，从长期目标来看是为了取代CMS回收器，G1回收器拥有独特的垃圾回收策略，G1属于分代垃圾回收器，区分新生代和老年代，依然有eden和from/to区,并不要求整个eden区或新生代、老年代空间都连续，它使用的是分区算法。并行性： G1回收期间可多线程同时工作。并发性： G1拥有与应用程序交替执行的能力，部分工作可与应用程序同时执行，在整个GC期间不会完全阻塞应用程序。分代GC： G1依然是一个分代收集器，但是它是兼顾新生代和老年代一起工作的，之前的垃圾收集器或者在新生代工作或者在老年代工作，因此这是一个很大的不同。空间整理： G1在回收过程中，不会像CMS那样在若干次GC后进行碎片整理，G1采用有效复制对象的方式减少空间碎片。可预见性：由于分区的原因，G1可以只选取部分区域进行回收，缩小了回收的范围，提高了性能。使用-XX:+UseG1GC应用G1收集器使用-XX:MaxGCPauseMillis指定最大的停顿时间使用-XX:ParallelGCThreads设置并行回收的线程数量 配置Tomcat参数（一）使用串行垃圾回收器1234-XX:+PrintGCDetails -Xmx32m -Xms32m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseSerialGC-XX:PermSize=32m 测试结果显示吞吐量为:871.8/sec 87KB/sec 配置Tomcat参数（二）扩大内存提高系统性能12345-XX:+PrintGCDetails -Xmx512m -Xms32m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseSerialGC-XX:PermSize=32m-Xloggc:d:/gc.log 测试结果显示吞吐量为:1383.31/sec 138KB/sec 配置Tomcat参数（三）调整初始堆大小12345-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseSerialGC-XX:PermSize=32m-Xloggc:d:/gc.log 测试结果显示吞吐量为:1501.3/sec 149.8KB/sec 配置Tomcat参数（四）测试ParNew回收器的表现12345-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseParNewGC-XX:PermSize=32m-Xloggc:d:/gc.log 测试结果显示吞吐量为:2130/sec 212KB/sec 配置Tomcat参数（五）测试ParallelOldGC回收器的表现1234567-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseParallelGC-XX:+UseParallelOldGC-XX:ParallelGCThreads=8-XX:PermSize=32M-Xloggc:d:/gc.log 测试结果显示吞吐量为:2236/sec 223KB/sec 配置Tomcat参数（五）测试CMS回收器的表现123456-XX:+PrintGCDetails -Xmx512m -Xms128m-XX:+HeapDumpOnOutOfMemoryError-XX:+UseConcMarkSweepGC-XX:ConcGCThreads=8-XX:PermSize=32M-Xloggc:d:/gc.log 测试结果显示吞吐量为:1813/sec 181KB/sec 源码：https://github.com/zxiang179/JVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JVM]]></title>
      <url>%2F2017%2F04%2F25%2FJVM%2F</url>
      <content type="text"><![CDATA[JVMjava虚拟机的原理与概述虚拟机可分为系统虚拟机和程序虚拟机系统虚拟机对物理计算机仿真。程序虚拟机是对物理计算机的仿真。 JVM结构- 类加载子系统：负责从文件系统或者网络加载class信息，加载的信息存放在一款称之为方法区的内存空间。 方法区：存放类信息、常量信息、常量池信息、包括字符串字面量和数字常量等。 java堆：在JVM启动时建立java堆，它是java程序最主要的内存工作区域，几乎所有的对象实例都存放到java堆中，堆空间是所有线程共享的。 直接内存： java的NIO库允许java程序直接使用内存从而提高性能，通常直接内存速度会优于java堆。读写频繁的场合可能会考虑使用。 java栈：每个JVM都有一个私有的栈，一个线程的java栈在线程创建的时候就被创建，java栈中保存着局部变量、方法参数、同时java的方法调用、返回值等。 本地方法栈和java栈类似，最大的不同是本地方法栈用于本地方法调用。java虚拟机允许java直接调用本地方法。(通常使用C编写) 垃圾收集系统是java的核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无序手工清理。 PC（Program Counter）寄存器：是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任何时刻，一个java线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器会指向当前正在被执行的指令，如果是本地方法，则PC寄存器值为undefined，寄存器存放如当前执行环境指针，程序计数器，操作栈指针，计算的变量指针等信息。 执行引擎是JVM最核心的组件，它负责执行JVM的字节码，一般会先进行编译成字节码后执行。 堆栈方法区的概念及联系堆解决的是数据存储的问题，即数据怎么放，放在哪里。栈解决的是程序的运行问题，即程序如何执行，或者说如何处理数据。方法区是辅助堆栈的块永久区(Perm)，解决堆栈信息的产生，是先决条件。我们创建一个新的对象，User：那么User类的一些信息(类信息，静态信息都存在于方法区中)而User类被实例化出来之后被存放在java堆中，一块内存空间。当我们去使用的时候都是使用User对象的引用，形如User user=new User();这里的user就是存放在java栈中的，即User真实对象的一个引用。 辨清java堆java堆是和应用程序关系最密切的内存空间，几乎所有对象都存放在其中，并且java堆完全是自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显示的释放。根据垃圾回收机制不同，java堆可能有不同的结构。最为常见的就是将整个java堆分为新生代和老年代。其中新生代存放新生的对象或者年龄不大的对象，老年代则存放老年对象。新生代分为eden区、s0区、s1区，s0和s1也被称为from和to区域，它们是两块大小相等并且可以互换角色的空间。(复制算法)绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则会进入s0或者s1区，之后每经过一次新生代回收，如果对象存活，则它的年龄就加1，当对象达到一定年龄后，则进入老年代。 java栈java栈是一个线程私有的内存空间，一个栈一般由三个部分组成：局部变量表，操作数栈和帧数据区。局部变量表：用于报错函数的参数及局部变量。操作数栈：主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。帧数据区：除局部变量表和操作数栈，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便程序访问常量池。另外，当函数返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理表也是帧数据区的一部分。 java方法区java方法区和堆一样，方法区是一个所有线程共享的内存区域，它保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少类。如果系统定义太多的类，导致方法区移除。java虚拟机同样会抛出内存溢出错误。方法区可以理解为永久区（Perm）。 源码：https://github.com/zxiang179/JVM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F25%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
