---
title: 工厂方法模式
date: 2017-05-04
tags: 设计模式
categories: JAVA
---

>**工厂方法模式（Factory Method）：**定义一个创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。

![](http://i.imgur.com/vDVh64R.png)

<!-- more -->

**Operation.java**
```
public interface Operation {
	public double getResult(double number1,double number2) throws Exception;
}

class OperationAdd implements Operation{
	@Override
	public double getResult(double number1, double number2) {
		double result=0;
		return result=number1+number2;
	}

}

class OperationSub implements Operation{

	@Override
	public double getResult(double number1, double number2) {
		double result=0;
		return result=number1-number2;
	}
}

class OperationMul implements Operation{

	@Override
	public double getResult(double number1, double number2) {
		double result=0;
		return result=number1*number2;
	}
}

class OperationDiv implements Operation{
	@Override
	public double getResult(double number1, double number2) throws Exception {
		double result=0;
		if(number2==0){
			throw new Exception("除数不能为0");
		}
			result=number1/number2;
		return result;
	}
}
```
**先构造一个工厂接口，然后加减乘除各自建造一个具体工厂去实现这个接口**
```
public interface IFactory {
	Operation createOperation();
}

class AddFactory implements IFactory{
	@Override
	public Operation createOperation() {
		return new OperationAdd();
	}
}

class SubFactory implements IFactory{
	@Override
	public Operation createOperation() {
		return new OperationSub();
	}
}

class MulFactory implements IFactory{
	@Override
	public Operation createOperation() {
		return new OperationMul();
	}
}

class DivFactory implements IFactory{
	@Override
	public Operation createOperation() {
		return new OperationDiv();
	}
}
```
**Test.java**
```
package zx.factorymethod.test1;

public class Test {
	public static void main(String[] args) throws Exception {
		AddFactory addFactory = new AddFactory();
		Operation operationAdd = addFactory.createOperation();
		System.out.println(operationAdd.getResult(1, 1));
	}

}
```
工厂方法模式实现时，客户端需要决定实例化哪个工厂来实现运算类。也就是说，工厂方法模式把简单工厂的内部逻辑判断移到客户端代码来进行。如果想要加功能，本来是改工厂，现在是修改客户端。

## 具体实例(雷锋/志愿者工厂)

### 简单工厂

>**简单工厂：根据传入的参数返回特定的对象。**
```
public class LeiFeng {
	public void Sweep(){
		System.out.println("扫地");
	}
	public void Wash(){
		System.out.println("洗衣");
	}
	public void BuyRice(){
		System.out.println("买米");
	}
}

class UnderGraduate extends LeiFeng{
}

class Volunteer extends LeiFeng{
}
```
### 工厂方法

>**工厂方法：根据创建的工厂类型，返回特定的对象**

雷锋工厂
**IFactory.java**
```
public interface IFactory {
	LeiFeng createLeiFeng();
}

class UnderGraduateFactory implements IFactory{
	@Override
	public LeiFeng createLeiFeng() {
		return new UnderGraduate();
	}
}

class VolunteerFactory implements IFactory{
	@Override
	public LeiFeng createLeiFeng() {
		return new Volunteer();
	}
}
```
*IFactory为工厂接口，UnderGraduateFactory和VolunteerFactory为实现这个接口的具体工厂的实现。*

工厂方法模式的调用
**Test.java**
```
public class Test {
	public static void main(String[] args) {
		IFactory underGraduateFactory = new UnderGraduateFactory();
		LeiFeng leiFeng = underGraduateFactory.createLeiFeng();
		leiFeng.Sweep();
		leiFeng.BuyRice();
		leiFeng.Wash();
	}
}
```
 **工厂方法模式的使用场合**
 
- 客户端不知道它要创建的具体是哪一个子类。
- 一个类想要由自己的子类来定义某对象的创建过程。
- 类将创建某对象的职责代理给一些帮助子类中的一个，并且你想要将哪-一个子类作为代理的信息进行局部化。

源码：https://github.com/zxiang179/DesignPattern